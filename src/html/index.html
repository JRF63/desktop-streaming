<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>WebRTC Screen Duplicator Client</title>
    <style>
        .container {
            display: flex;
        }

        video {
            width: 100%;
        }
    </style>
</head>

<body>
    <div id="video" class="container"></div>
</body>

<script>
    const ws = new WebSocket('ws://' + location.host + '/ws');
    const pc = new RTCPeerConnection();
    const polite = false;

    let ignoreOffer = false;
    let makingOffer = false;

    try {
        pc.addTransceiver('video', { 'direction': 'recvonly' });
    } catch (err) {
        console.log(err);
    }

    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    async function waitForWebSocket() {
        while (true) {
            if (ws.readyState === WebSocket.OPEN) {
                return;
            }
            await sleep(500);
        }
    }

    // pc.onnegotiationneeded = async () => {
    //     try {
    //         makingOffer = true;
    //         await pc.setLocalDescription();
    //         const json = JSON.stringify({ type: "Sdp", data: pc.localDescription });
    //         await waitForWebSocket();
    //         ws.send(json);
    //     } catch (err) {
    //         console.error(err);
    //     } finally {
    //         makingOffer = false;
    //     }
    // };

    pc.oniceconnectionstatechange = async () => {
        if (pc.iceConnectionState === "failed") {
            pc.restartIce();
        }
    };

    pc.onicecandidate = async ({ candidate }) => {
        if (candidate !== null) {
            await waitForWebSocket();
            try {
                const json = JSON.stringify({ type: "IceCandidate", data: candidate });
                ws.send(json);
            } catch (err) {
                console.log(err);
            }
        }
    };

    pc.ontrack = ({ track, streams }) => {
        console.log("ontrack");
        var el = document.createElement(track.kind)
        el.srcObject = streams[0]
        el.autoplay = true
        el.controls = true

        // track.onmute = () => {
        //     el.parentNode.removeChild(el);
        // };

        document.getElementById('video').appendChild(el)
    };

    // https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Perfect_negotiation#implementing_perfect_negotiation
    ws.onmessage = async (event) => {
        try {
            const message = JSON.parse(event.data);
            console.log(message);
            switch (message.type) {
                case "Sdp":
                    const description = message.data;
                    const offerCollision =
                        description.type === "offer" &&
                        (makingOffer || pc.signalingState !== "stable");

                    ignoreOffer = !polite && offerCollision;
                    console.log('ignoreOffer: ' + ignoreOffer);
                    if (ignoreOffer) {
                        return;
                    }

                    await pc.setRemoteDescription(new RTCSessionDescription(description));
                    if (description.type === "offer") {
                        await pc.setLocalDescription();
                        const json = JSON.stringify({ type: "Sdp", data: pc.localDescription });
                        console.log(pc.localDescription);
                        ws.send(json);
                    }

                    break;
                case "IceCandidate":
                    try {
                        await pc.addIceCandidate(message.data);
                    } catch (err) {
                        if (!ignoreOffer) {
                            throw err;
                        }
                    }
                    break;
                case "Bye":
                    pc.close();
                    break;
                default:
                    console.log("Unknown message type: " + message.type);
            }
        } catch (err) {
            console.error(err);
        }
    };
</script>

</html>